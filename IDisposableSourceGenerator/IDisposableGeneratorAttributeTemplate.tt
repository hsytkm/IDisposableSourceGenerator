<#@ template debug="false" hostspecific="false" language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY IDISPOSABLEGENERATOR. DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;

namespace IDisposableSourceGenerator
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    internal sealed class IDisposableGeneratorAttribute : Attribute
    {
        public Type? CompositeDisposableType { get; }
        public string? CompositeDisposableFieldName { get; }
        public IDisposableGeneratorOptions Options { get; }

        public IDisposableGeneratorAttribute(
            Type? compositeDisposableType = null,
            string? compositeDisposableFieldName = null,
            IDisposableGeneratorOptions options = IDisposableGeneratorOptions.None)
        {
            CompositeDisposableType = compositeDisposableType ?? typeof(IDisposableSourceGenerator.SimpleCompositeDisposable);
            CompositeDisposableFieldName = string.IsNullOrWhiteSpace(compositeDisposableFieldName) ? "_disposables" : compositeDisposableFieldName!;
            Options = options;
        }
    }

    [Flags]
    internal enum IDisposableGeneratorOptions
    {
        None = 0x0000,
        DisposeUnmanagedObjectsMethod = 0x0001,     // DisposeUnmanagedObjects()
        SetLargeFieldsToNullMethod = 0x0002,        // SetLargeFieldsToNull()
        OnDisposingMethod = 0x0004,                 // OnDisposing()
    }

    /// <summary>Manages multiple IDisposable objects</summary>
    internal class SimpleCompositeDisposable : IDisposable, ICollection<IDisposable>
    {
        private readonly List<IDisposable> _disposables = new List<IDisposable>();
        private bool _disposed;
        private readonly object _lockObject = new object();

        /// <summary>Gets the enumerator of the IDisposable collection.</summary>
        /// <returns>IEnumerator&lt;IDisposable&gt;</returns>
        public IEnumerator<IDisposable> GetEnumerator()
        {
            ThrowExceptionIfDisposed();
            lock (_lockObject)
            {
                return ((IEnumerable<IDisposable>)_disposables.ToArray()).GetEnumerator();
            }
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            ThrowExceptionIfDisposed();
            lock (_lockObject)
            {
                return ((IEnumerable<IDisposable>)_disposables.ToArray()).GetEnumerator();
            }
        }

        /// <summary>Add an object at the end</summary>
        /// <param name="item">Objects to add</param>
        public void Add(IDisposable item)
        {
            if (item is null) throw new ArgumentNullException(nameof(item));

            ThrowExceptionIfDisposed();
            lock (_lockObject)
            {
                _disposables.Add(item);
            }
        }

        /// <summary>Delete all objects</summary>
        public void Clear()
        {
            ThrowExceptionIfDisposed();
            lock (_lockObject)
            {
                _disposables.Clear();
            }
        }

        /// <summary>Determine if an objects is included in this collection or not</summary>
        /// <param name="item">Elements that you want to determine if they are included in the collection</param>
        /// <returns>Whether or not it is included</returns>
        public bool Contains(IDisposable item)
        {
            if (item is null) throw new ArgumentNullException(nameof(item));

            ThrowExceptionIfDisposed();
            lock (_lockObject)
            {
                return _disposables.Contains(item);
            }
        }

        /// <summary>
        /// Copies the entire array to a compatible one-dimensional array. The copy operation starts from the specified index of the destination array.
        /// </summary>
        /// <param name="array">Copy destination array</param>
        /// <param name="arrayIndex">Index of where in the destination array to perform the copy operation from</param>
        public void CopyTo(IDisposable[] array, int arrayIndex)
        {
            ThrowExceptionIfDisposed();
            lock (_lockObject)
            {
                _disposables.CopyTo(array, arrayIndex);
            }
        }

        /// <summary>Get the number of objects actually stored</summary>
        public int Count
        {
            get
            {
                ThrowExceptionIfDisposed();
                lock (_lockObject)
                {
                    return _disposables.Count;
                }
            }
        }

        /// <summary>Gets whether this collection is read-only or not. (Always returns false)</summary>
        public bool IsReadOnly
        {
            get
            {
                ThrowExceptionIfDisposed();
                return false;
            }
        }

        /// <summary>Deletes the first specific object found.</summary>
        /// <param name="item">Object to be deleted</param>
        /// <returns>whether it was possible to delete it</returns>
        public bool Remove(IDisposable item)
        {
            if (item is null) throw new ArgumentNullException(nameof(item));

            ThrowExceptionIfDisposed();

            lock (_lockObject)
            {
                return _disposables.Remove(item);
            }
        }

        /// <summary>Dispose all the objects in this collection</summary>
        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        /// <summary>dispose method</summary>
        /// <param name="disposing"></param>
        protected virtual void Dispose(bool disposing)
        {
            if (_disposed) return;

            if (disposing)
            {
                lock (_lockObject)
                {
                    _disposables.ForEach(item => item.Dispose());
                }
            }
            _disposed = true;
        }

        /// <summary>throw exception if disposed</summary>
        protected void ThrowExceptionIfDisposed()
        {
            if (_disposed)
                throw new ObjectDisposedException(nameof(SimpleCompositeDisposable));
        }
    }
}
